#BlueJ class context
comment0.params=
comment0.target=void\ init()
comment1.params=
comment1.target=void\ doBubblesort()
comment10.params=data\ first\ last
comment10.target=void\ medianOfThree(int[],\ int,\ int)
comment11.params=data\ first\ last
comment11.target=void\ binaryInsertionSort(int[],\ int,\ int)
comment12.params=
comment12.target=void\ inOrder()
comment13.params=
comment13.target=void\ reverseOrder()
comment14.params=
comment14.target=void\ randomOrder()
comment15.params=brightness
comment15.target=java.awt.Color\ colorDisplay(float)
comment2.params=
comment2.target=void\ doBinaryInsertionSort()
comment3.params=data\ first\ last
comment3.target=void\ doBinaryInsertionSort(int[],\ int,\ int)
comment4.params=data\ key\ first\ last
comment4.target=int\ binarySearch(int[],\ int,\ int,\ int)
comment5.params=
comment5.target=void\ doMergeSort()
comment6.params=a\ left\ right
comment6.target=void\ mergeSort(int[],\ int,\ int)
comment7.params=a\ left\ right\ rightEnd
comment7.target=void\ merge(int[],\ int,\ int,\ int)
comment8.params=data
comment8.target=void\ doQuickSort(int[])
comment8.text=private\ void\ mergeSort(int[]\ data,\ int\ begin,\ int\ end)\n\ \ \ {\n\ \ \ \ \ \ if(end\ -\ begin\ <\ 1){}\n\ \ \ \ \ \ \n\ \ \ \ \ \ else\n\ \ \ \ \ \ {\n\ \ \ \ \ \ \ \ \ int\ mid\ \=\ (begin\ +\ end)\ /2;\n\ \ \ \ \ \ \ \ \ int\ length\ \ \=\ mid\ -\ begin;\n\ \ \ \ \ \ \ \ \ int[]\ left\ \=\ new\ int[mid\ -\ begin];\n\ \ \ \ \ \ \ \ \ for(int\ i\=\ 0;\ i\ <\ length;\ i\ ++)\n\ \ \ \ \ \ \ \ \ {\n\ \ \ \ \ \ \ \ \ \ \ \ left[i]\ \=\ data[i];\n\ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ \ int[]\ right\ \=\ new\ int[end\ -\ mid\ -\ 1];\n\ \ \ \ \ \ \ \ \ for(int\ j\ \=0\ ;\ j\ <\ right.length;\ j++)\n\ \ \ \ \ \ \ \ \ {\n\ \ \ \ \ \ \ \ \ \ \ \ right[j]\ \=\ data[j];\n\ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ \ \ mergeSort(data,\ begin,\ mid);\n\ \ \ \ \ \ \ \ \ mergeSort(data,\ mid\ +\ 1,\ end);\n\ \ \ \ \ \ \ \ \ merge(left,\ right);\n\ \ \ \ \ \ }\n\ \ \ }\n\n\n\ \ \ private\ void\ merge(int[]\ x,int[]\ y)\n\ \ \ {\n\ \ \ \ \ \ \ //create\ the\ new\ list\ that\ can\ obtain\ both\ lists\n\ \ \ \ \ \ \ int[]\ z\ \=\ new\ int[x.length\ +\ y.length];\n\n\n\ \ \ \ \ \ \ //initalize\ the\ all\ the\ track(which\ is\ the\ size)\ of\ the\ list\n\ \ \ \ \ \ \ int\ i\ \=\ 0;\n\ \ \ \ \ \ \ int\ j\ \=\ 0;\n\ \ \ \ \ \ \ int\ k\ \=\ 0;\n\ \ \ \n\ \ \ \ \ \ doPaint\ \=\ PaintType.RANGE;\n\ \ \ \ \ \ \ //looping\ through\ the\ list,\ but\ one\ thing\ you\ need\ to\ know\ is\ its\ length\n\ \ \ \ \ \ \ while(i<\ x.length\ &&\ j\ <\ y.length)\n\ \ \ \ \ \ \ {\n\ \ \ \ \ \ //after\ you\ add\ smaller\ item(aftre\ comparison)into\ the\ merge\ list,\ you\ are\ going\ to\ the\ next\ item\ in\ the\ list\n\ \ \ \ \ \ //you\ know\ that\ smaller\ item\ is\ at\ the\ x\ list,\ you\ are\ going\ to\ the\ next\ item\ in\ the\ x\ list\ and\ do\ comparison\n\ \ \ \ \ \ if(x[i]\ <\ y[j])\n\ \ \ \ \ \ {\n\ \ \ \ \ \ \ \ \ \ z[k]\ \=\ x[i];\n\ \ \ \ \ \ \ \ \ \ i++;\ \ \ \n\ \ \ \ \ \ \ \ \ \ leftRange\ \=\ i;\n\ \ \ \ \ \ \ \ \ \ rightRange\ \=\ k;\n\ \ \ \ \ \ }\n\ \ \ \ \ \ //comparing\ two\ items\ and\ you\ know\ that\ smaller\ item\ is\ at\ the\ y\ list,\ you\ are\ keeping\ track\ of\ the\ next\ thing\ in\ the\ y\ list.\n\ \ \ \ \ \ else\n\ \ \ \ \ \ {\n\ \ \ \ \ \ \ \ \ \ z[k]\ \=\ y[j];\n\ \ \ \ \ \ \ \ \ \ j++;\n\ \ \ \ \ \ \ \ \ \ leftRange\ \=\ j;\n\ \ \ \ \ \ \ \ \ \ rightRange\ \=\ k;\n\ \ \ \ \ \ }\n\ \ \ \ \ \ //for\ sure\ you\ know\ that\ position\ must\ be\ tracked\ as\ well\n\ \ \ \ \ \ k++;\n\ \ \ \ \ \ \ }\n\n\ \ \ \ \ \ \ //if\ the\ x\ reaches\ its\ limite,\ you\ want\ to\ copy\ all\ the\ things\ in\ the\ y\ list\n\ \ \ \ \ \ \ while(j\ <\ y.length)\n\ \ \ \ \ \ \ {\n\ \ \ \ \ \ \ \ \ z[k]\ \=\ y[j];\n\ \ \ \ \ \ \ \ \ k++;\n\ \ \ \ \ \ \ \ \ j++;\n\ \ \ \ \ \ \ \ \ leftRange\ \=\ i;\n\ \ \ \ \ \ \ \ \ rightRange\ \=\ k;\n\ \ \ \ \ \ \ }\ \n\ \ \ \ \ \ \ //if\ the\ y\ reaches\ its\ last\ item,\ you\ want\ to\ copy\ the\ rest\ of\ the\ thing\ in\ the\ x\ list\n\ \ \ \ \ \ \ while(i\ <\ x.length)\n\ \ \ \ \ \ \ {\n\ \ \ \ \ \ z[k]\ \=\ x[i];\n\ \ \ \ \ \ \ \ \ k++;\n\ \ \ \ \ \ \ \ \ i++;\n\ \ \ \ \ \ \ \ \ leftRange\ \=\ i;\n\ \ \ \ \ \ \ \ \ \ rightRange\ \=\ k;\n\ \ \ \ \ \ \ }\n\ \ \ \n\ \ \ \ \ \ \ \n\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \n\ \ \ \ \ \ picture.paint(picture.getGraphics());\n\n\ \ \ }\n\ \ \ /**void\ mergeSort(int\ a[],\ int\ low,\ int\ high)\ \ {\ \n\ \ \ \ \ \ if(high\ -\ low\ <\ 1){}\n\ \ \ \ \ \ \n\ \ \ \ \ \ else\n\ \ \ \ \ \ {\n\ \ \ \ \ \ \ int\ length\ \=\ high-low+1;\ \n\ \ \ \ \ \ \ int\ middle\ \=\ (low+high)\ /\ 2;\ \n\ \ \ \ \ \ \ mergeSort(a,\ low,\ middle);\ \n\ \ \ \ \ \ \ mergeSort(a,\ middle+1,\ high);\ \n\ \ \ \ \ \ \ int\ working[]\ \=\ new\ int[length];\ \n\ \ \ \ \ \ \ for(int\ i\ \=\ 0;\ i\ <\ length;\ i++)\ \ \n\ \ \ \ \ \ \ \ \ \ \ working[i]\ \=\ a[low+i];\ \n\ \ \ \ \ \ \ int\ m1\ \=\ 0;\ \ \n\ \ \ \ \ \ \ int\ m2\ \=\ middle-low+1;\ \n\ \ \ \ \ \ \ for(int\ i\ \=\ 0;\ i\ <\ length;\ i++)\ {\ \n\ \ \ \ \ \ \ \ \ if(m2\ <\=\ high-low)\ \ \n\ \ \ \ \ \ \ \ \ \ \ \ \ if(m1\ <\=\ middle-low)\ \ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(working[m1]\ >\ working[m2])\ \ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a[i+low]\ \=\ working[m2++];\ \ \ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ else\ \ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a[i+low]\ \=\ working[m1++];\ \n\ \ \ \ \ \ \ \ \ \ \ \ \ else\ \ \n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a[i+low]\ \=\ working[m2++];\ \n\ \ \ \ \ \ \ \ \ else\ \ \n\ \ \ \ \ \ \ \ \ \ \ \ \ a[i+low]\ \=\ working[m1++];\ \n\n\ \ \ \ \ \ \ \ \ doPaint\ \=\ PaintType.RANGE;\n\ \ \ \ \ \ \ \ \ leftRange\ \=\ m1;\n\ \ \ \ \ \ \ \ \ rightRange\ \=\ m2;\n\ \ \ \ \ \ \ \ \ picture.paint(picture.getGraphics());\n\ \ \ \ \ \ \ \ \ }\n\ \ \ \ \ \ \ }\ \n\ \ \ \ \ }\ \n
comment9.params=data\ first\ last
comment9.target=int\ partition(int[],\ int,\ int)
numComments=16
